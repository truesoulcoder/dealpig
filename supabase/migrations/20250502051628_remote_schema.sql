drop policy "Allow authenticated users to delete leads" on "public"."leads";

drop policy "Allow authenticated users to insert leads" on "public"."leads";

drop policy "Allow authenticated users to update leads" on "public"."leads";

alter table "public"."lead_sources" drop constraint "lead_sources_name_key";

alter table "public"."profiles" drop constraint "profiles_username_key";

alter table "public"."profiles" drop constraint "username_length";

drop index if exists "public"."lead_sources_name_key";

drop index if exists "public"."profiles_username_key";

create table "public"."campaign_leads" (
    "id" uuid not null default uuid_generate_v4(),
    "campaign_id" uuid not null,
    "lead_source_id" uuid not null,
    "lead_record_id" uuid not null,
    "status" character varying default 'PENDING'::character varying,
    "processed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."campaign_leads" enable row level security;

create table "public"."campaign_senders" (
    "id" uuid not null default uuid_generate_v4(),
    "campaign_id" uuid not null,
    "sender_id" uuid not null,
    "emails_sent_today" integer default 0,
    "total_emails_sent" integer default 0,
    "last_sent_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."campaign_senders" enable row level security;

create table "public"."campaigns" (
    "id" uuid not null default uuid_generate_v4(),
    "name" character varying not null,
    "description" text,
    "status" character varying default 'DRAFT'::character varying,
    "email_template_id" uuid,
    "loi_template_id" uuid,
    "leads_per_day" integer default 10,
    "start_time" character varying default '09:00'::character varying,
    "end_time" character varying default '17:00'::character varying,
    "min_interval_minutes" integer default 15,
    "max_interval_minutes" integer default 45,
    "attachment_type" character varying default 'PDF'::character varying,
    "tracking_enabled" boolean default true,
    "total_leads" integer default 0,
    "leads_worked" integer default 0,
    "company_logo_path" character varying,
    "email_subject" character varying,
    "email_body" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "user_id" uuid
);


alter table "public"."campaigns" enable row level security;

create table "public"."email_events" (
    "id" uuid not null default uuid_generate_v4(),
    "email_id" uuid,
    "event_type" character varying not null,
    "recipient_email" character varying not null,
    "campaign_id" uuid,
    "metadata" jsonb,
    "user_agent" text,
    "ip_address" character varying,
    "created_at" timestamp with time zone default now()
);


alter table "public"."email_events" enable row level security;

create table "public"."emails" (
    "id" uuid not null default uuid_generate_v4(),
    "lead_source_id" uuid not null,
    "lead_record_id" uuid not null,
    "sender_id" uuid not null,
    "campaign_id" uuid,
    "subject" character varying not null,
    "body" text not null,
    "loi_path" character varying,
    "status" character varying default 'SENT'::character varying,
    "sent_at" timestamp with time zone,
    "delivered_at" timestamp with time zone,
    "bounced_at" timestamp with time zone,
    "bounce_reason" text,
    "tracking_id" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."emails" enable row level security;

create table "public"."normalized_leads" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "original_lead_id" bigint,
    "contact_name" text,
    "contact_email" text,
    "property_address" text,
    "property_city" text,
    "property_state" text,
    "property_postal_code" text,
    "property_type" text,
    "baths" text,
    "beds" integer,
    "year_built" integer,
    "square_footage" integer,
    "wholesale_value" numeric,
    "assessed_total" numeric,
    "mls_curr_status" text,
    "mls_curr_days_on_market" integer
);


alter table "public"."normalized_leads" enable row level security;

create table "public"."senders" (
    "id" uuid not null default uuid_generate_v4(),
    "name" character varying not null,
    "email" character varying not null,
    "title" character varying,
    "daily_quota" integer default 50,
    "emails_sent" integer default 0,
    "last_sent_at" timestamp with time zone,
    "oauth_token" text,
    "refresh_token" text,
    "user_id" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."senders" enable row level security;

create table "public"."templates" (
    "id" uuid not null default uuid_generate_v4(),
    "name" character varying not null,
    "subject" character varying,
    "content" text not null,
    "type" character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."templates" enable row level security;

alter table "public"."lead_sources" drop column "description";

alter table "public"."lead_sources" add column "file_name" character varying not null;

alter table "public"."lead_sources" add column "is_active" boolean default true;

alter table "public"."lead_sources" add column "last_imported" timestamp with time zone not null default now();

alter table "public"."lead_sources" add column "metadata" jsonb;

alter table "public"."lead_sources" add column "record_count" integer not null default 0;

alter table "public"."lead_sources" add column "storage_path" character varying;

alter table "public"."lead_sources" alter column "created_at" drop not null;

alter table "public"."lead_sources" alter column "name" set data type character varying using "name"::character varying;

alter table "public"."lead_sources" alter column "updated_at" drop not null;

alter table "public"."leads" alter column "absentee_owner" set data type boolean using "absentee_owner"::boolean;

alter table "public"."leads" alter column "active_investor_owned" set data type boolean using "active_investor_owned"::boolean;

alter table "public"."leads" alter column "assessed_year" set data type integer using "assessed_year"::integer;

alter table "public"."leads" alter column "baths" set data type numeric using "baths"::numeric;

alter table "public"."leads" alter column "beds" set data type integer using "beds"::integer;

alter table "public"."leads" alter column "contact1_phone_1_dnc" set data type boolean using "contact1_phone_1_dnc"::boolean;

alter table "public"."leads" alter column "contact1_phone_1_litigator" set data type boolean using "contact1_phone_1_litigator"::boolean;

alter table "public"."leads" alter column "contact1_phone_2_dnc" set data type boolean using "contact1_phone_2_dnc"::boolean;

alter table "public"."leads" alter column "contact1_phone_2_litigator" set data type boolean using "contact1_phone_2_litigator"::boolean;

alter table "public"."leads" alter column "contact1_phone_3_dnc" set data type boolean using "contact1_phone_3_dnc"::boolean;

alter table "public"."leads" alter column "contact1_phone_3_litigator" set data type boolean using "contact1_phone_3_litigator"::boolean;

alter table "public"."leads" alter column "contact2_phone_1_dnc" set data type boolean using "contact2_phone_1_dnc"::boolean;

alter table "public"."leads" alter column "contact2_phone_1_litigator" set data type boolean using "contact2_phone_1_litigator"::boolean;

alter table "public"."leads" alter column "contact2_phone_2_dnc" set data type boolean using "contact2_phone_2_dnc"::boolean;

alter table "public"."leads" alter column "contact2_phone_2_litigator" set data type boolean using "contact2_phone_2_litigator"::boolean;

alter table "public"."leads" alter column "contact2_phone_3_dnc" set data type boolean using "contact2_phone_3_dnc"::boolean;

alter table "public"."leads" alter column "contact2_phone_3_litigator" set data type boolean using "contact2_phone_3_litigator"::boolean;

alter table "public"."leads" alter column "contact3_phone_1_dnc" set data type boolean using "contact3_phone_1_dnc"::boolean;

alter table "public"."leads" alter column "contact3_phone_1_litigator" set data type boolean using "contact3_phone_1_litigator"::boolean;

alter table "public"."leads" alter column "contact3_phone_2_dnc" set data type boolean using "contact3_phone_2_dnc"::boolean;

alter table "public"."leads" alter column "contact3_phone_2_litigator" set data type boolean using "contact3_phone_2_litigator"::boolean;

alter table "public"."leads" alter column "contact3_phone_3_dnc" set data type boolean using "contact3_phone_3_dnc"::boolean;

alter table "public"."leads" alter column "contact3_phone_3_litigator" set data type boolean using "contact3_phone_3_litigator"::boolean;

alter table "public"."leads" alter column "fireplace" set data type integer using "fireplace"::integer;

alter table "public"."leads" alter column "last_sales_date" set data type date using "last_sales_date"::date;

alter table "public"."leads" alter column "last_sales_price" set data type numeric using "last_sales_price"::numeric;

alter table "public"."leads" alter column "mls_curr_baths" set data type numeric using "mls_curr_baths"::numeric;

alter table "public"."leads" alter column "mls_curr_beds" set data type integer using "mls_curr_beds"::integer;

alter table "public"."leads" alter column "mls_curr_days_on_market" set data type integer using "mls_curr_days_on_market"::integer;

alter table "public"."leads" alter column "mls_curr_list_date" set data type date using "mls_curr_list_date"::date;

alter table "public"."leads" alter column "mls_curr_sold_date" set data type date using "mls_curr_sold_date"::date;

alter table "public"."leads" alter column "mls_curr_sqft" set data type integer using "mls_curr_sqft"::integer;

alter table "public"."leads" alter column "mls_curr_stories" set data type numeric using "mls_curr_stories"::numeric;

alter table "public"."leads" alter column "mls_curr_year_built" set data type integer using "mls_curr_year_built"::integer;

alter table "public"."leads" alter column "mls_prev_baths" set data type numeric using "mls_prev_baths"::numeric;

alter table "public"."leads" alter column "mls_prev_beds" set data type integer using "mls_prev_beds"::integer;

alter table "public"."leads" alter column "mls_prev_days_on_market" set data type integer using "mls_prev_days_on_market"::integer;

alter table "public"."leads" alter column "mls_prev_list_date" set data type date using "mls_prev_list_date"::date;

alter table "public"."leads" alter column "mls_prev_sold_date" set data type date using "mls_prev_sold_date"::date;

alter table "public"."leads" alter column "mls_prev_sqft" set data type integer using "mls_prev_sqft"::integer;

alter table "public"."leads" alter column "mls_prev_stories" set data type numeric using "mls_prev_stories"::numeric;

alter table "public"."leads" alter column "mls_prev_year_built" set data type integer using "mls_prev_year_built"::integer;

alter table "public"."leads" alter column "price_per_sqft" set data type numeric using "price_per_sqft"::numeric;

alter table "public"."leads" alter column "rental_estimate_high" set data type numeric using "rental_estimate_high"::numeric;

alter table "public"."leads" alter column "rental_estimate_low" set data type numeric using "rental_estimate_low"::numeric;

alter table "public"."leads" alter column "square_footage" set data type integer using "square_footage"::integer;

alter table "public"."leads" alter column "stories" set data type numeric using "stories"::numeric;

alter table "public"."leads" alter column "units" set data type integer using "units"::integer;

alter table "public"."leads" alter column "year_built" set data type integer using "year_built"::integer;

alter table "public"."profiles" drop column "username";

alter table "public"."profiles" drop column "website";

alter table "public"."profiles" add column "created_at" timestamp with time zone default now();

alter table "public"."profiles" add column "email" text;

CREATE UNIQUE INDEX campaign_leads_campaign_id_lead_source_id_lead_record_id_key ON public.campaign_leads USING btree (campaign_id, lead_source_id, lead_record_id);

CREATE UNIQUE INDEX campaign_leads_pkey ON public.campaign_leads USING btree (id);

CREATE UNIQUE INDEX campaign_senders_campaign_id_sender_id_key ON public.campaign_senders USING btree (campaign_id, sender_id);

CREATE UNIQUE INDEX campaign_senders_pkey ON public.campaign_senders USING btree (id);

CREATE UNIQUE INDEX campaigns_pkey ON public.campaigns USING btree (id);

CREATE UNIQUE INDEX email_events_pkey ON public.email_events USING btree (id);

CREATE UNIQUE INDEX emails_pkey ON public.emails USING btree (id);

CREATE UNIQUE INDEX emails_tracking_id_key ON public.emails USING btree (tracking_id);

CREATE INDEX idx_campaign_leads_campaign_id ON public.campaign_leads USING btree (campaign_id);

CREATE INDEX idx_campaign_leads_lead_source_id ON public.campaign_leads USING btree (lead_source_id);

CREATE INDEX idx_campaign_leads_status ON public.campaign_leads USING btree (status);

CREATE INDEX idx_campaign_senders_campaign_id ON public.campaign_senders USING btree (campaign_id);

CREATE INDEX idx_email_events_campaign_id ON public.email_events USING btree (campaign_id);

CREATE INDEX idx_email_events_created_at ON public.email_events USING btree (created_at);

CREATE INDEX idx_email_events_email_id ON public.email_events USING btree (email_id);

CREATE INDEX idx_email_events_event_type ON public.email_events USING btree (event_type);

CREATE INDEX idx_emails_lead_source_id ON public.emails USING btree (lead_source_id);

CREATE INDEX idx_emails_sender_id ON public.emails USING btree (sender_id);

CREATE INDEX idx_emails_status ON public.emails USING btree (status);

CREATE INDEX idx_emails_tracking_id ON public.emails USING btree (tracking_id);

CREATE INDEX idx_normalized_leads_email ON public.normalized_leads USING btree (contact_email);

CREATE INDEX idx_normalized_leads_property_address ON public.normalized_leads USING btree (property_address);

CREATE UNIQUE INDEX normalized_leads_pkey ON public.normalized_leads USING btree (id);

CREATE UNIQUE INDEX profiles_email_key ON public.profiles USING btree (email);

CREATE UNIQUE INDEX senders_email_key ON public.senders USING btree (email);

CREATE UNIQUE INDEX senders_pkey ON public.senders USING btree (id);

CREATE UNIQUE INDEX templates_pkey ON public.templates USING btree (id);

alter table "public"."campaign_leads" add constraint "campaign_leads_pkey" PRIMARY KEY using index "campaign_leads_pkey";

alter table "public"."campaign_senders" add constraint "campaign_senders_pkey" PRIMARY KEY using index "campaign_senders_pkey";

alter table "public"."campaigns" add constraint "campaigns_pkey" PRIMARY KEY using index "campaigns_pkey";

alter table "public"."email_events" add constraint "email_events_pkey" PRIMARY KEY using index "email_events_pkey";

alter table "public"."emails" add constraint "emails_pkey" PRIMARY KEY using index "emails_pkey";

alter table "public"."normalized_leads" add constraint "normalized_leads_pkey" PRIMARY KEY using index "normalized_leads_pkey";

alter table "public"."senders" add constraint "senders_pkey" PRIMARY KEY using index "senders_pkey";

alter table "public"."templates" add constraint "templates_pkey" PRIMARY KEY using index "templates_pkey";

alter table "public"."campaign_leads" add constraint "campaign_leads_campaign_id_fkey" FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE CASCADE not valid;

alter table "public"."campaign_leads" validate constraint "campaign_leads_campaign_id_fkey";

alter table "public"."campaign_leads" add constraint "campaign_leads_campaign_id_lead_source_id_lead_record_id_key" UNIQUE using index "campaign_leads_campaign_id_lead_source_id_lead_record_id_key";

alter table "public"."campaign_leads" add constraint "campaign_leads_lead_source_id_fkey" FOREIGN KEY (lead_source_id) REFERENCES lead_sources(id) ON DELETE CASCADE not valid;

alter table "public"."campaign_leads" validate constraint "campaign_leads_lead_source_id_fkey";

alter table "public"."campaign_senders" add constraint "campaign_senders_campaign_id_fkey" FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE CASCADE not valid;

alter table "public"."campaign_senders" validate constraint "campaign_senders_campaign_id_fkey";

alter table "public"."campaign_senders" add constraint "campaign_senders_campaign_id_sender_id_key" UNIQUE using index "campaign_senders_campaign_id_sender_id_key";

alter table "public"."campaign_senders" add constraint "campaign_senders_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES senders(id) ON DELETE CASCADE not valid;

alter table "public"."campaign_senders" validate constraint "campaign_senders_sender_id_fkey";

alter table "public"."campaigns" add constraint "campaigns_email_template_id_fkey" FOREIGN KEY (email_template_id) REFERENCES templates(id) not valid;

alter table "public"."campaigns" validate constraint "campaigns_email_template_id_fkey";

alter table "public"."campaigns" add constraint "campaigns_loi_template_id_fkey" FOREIGN KEY (loi_template_id) REFERENCES templates(id) not valid;

alter table "public"."campaigns" validate constraint "campaigns_loi_template_id_fkey";

alter table "public"."campaigns" add constraint "campaigns_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."campaigns" validate constraint "campaigns_user_id_fkey";

alter table "public"."email_events" add constraint "email_events_campaign_id_fkey" FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE SET NULL not valid;

alter table "public"."email_events" validate constraint "email_events_campaign_id_fkey";

alter table "public"."email_events" add constraint "email_events_email_id_fkey" FOREIGN KEY (email_id) REFERENCES emails(id) ON DELETE CASCADE not valid;

alter table "public"."email_events" validate constraint "email_events_email_id_fkey";

alter table "public"."emails" add constraint "emails_campaign_id_fkey" FOREIGN KEY (campaign_id) REFERENCES campaigns(id) ON DELETE SET NULL not valid;

alter table "public"."emails" validate constraint "emails_campaign_id_fkey";

alter table "public"."emails" add constraint "emails_lead_source_id_fkey" FOREIGN KEY (lead_source_id) REFERENCES lead_sources(id) ON DELETE CASCADE not valid;

alter table "public"."emails" validate constraint "emails_lead_source_id_fkey";

alter table "public"."emails" add constraint "emails_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES senders(id) ON DELETE CASCADE not valid;

alter table "public"."emails" validate constraint "emails_sender_id_fkey";

alter table "public"."emails" add constraint "emails_tracking_id_key" UNIQUE using index "emails_tracking_id_key";

alter table "public"."profiles" add constraint "profiles_email_key" UNIQUE using index "profiles_email_key";

alter table "public"."senders" add constraint "senders_email_key" UNIQUE using index "senders_email_key";

alter table "public"."senders" add constraint "senders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE SET NULL not valid;

alter table "public"."senders" validate constraint "senders_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_dynamic_lead_table(table_name_param text, column_definitions text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  full_table_name text;
  sanitized_table_name text;
BEGIN
  -- Basic sanitization and add suffix
  sanitized_table_name := lower(regexp_replace(table_name_param, '[^a-zA-Z0-9_]+', '', 'g'));
  IF sanitized_table_name = '' OR sanitized_table_name = 'leads' THEN
      RAISE EXCEPTION 'Invalid table name provided: %', table_name_param;
  END IF;
  full_table_name := sanitized_table_name || '_leads';

  -- Validate column definitions (basic check for potentially harmful commands - needs improvement for production)
  IF column_definitions ILIKE '%drop %' OR column_definitions ILIKE '%delete %' OR column_definitions ILIKE '%update %' THEN
      RAISE EXCEPTION 'Invalid characters found in column definitions.';
  END IF;

  -- Create the table with the provided columns
  EXECUTE format('
    CREATE TABLE IF NOT EXISTS public.%I (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      %s, -- column_definitions are inserted here
      processed BOOLEAN DEFAULT FALSE, -- Flag to track if this record has been normalized
      normalized_lead_id UUID, -- Reference to the ID in the leads table once normalized
      created_at TIMESTAMPTZ DEFAULT NOW(),
      updated_at TIMESTAMPTZ DEFAULT NOW()
    )', full_table_name, column_definitions);

  -- Enable RLS on the new table
  EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY', full_table_name);

  -- Create policies for the new table (using the policy creation function defined earlier)
  PERFORM public.create_policy_if_not_exists(
    format('Enable read access for authenticated users on %I', full_table_name),
    full_table_name,
    'SELECT',
    'auth.role() IN (''authenticated'', ''service_role'')'
  );
  PERFORM public.create_policy_if_not_exists(
    format('Enable insert for authenticated users on %I', full_table_name),
    full_table_name,
    'INSERT',
    'true',
    'auth.role() IN (''authenticated'', ''service_role'')'
  );
   PERFORM public.create_policy_if_not_exists(
    format('Enable update for authenticated users on %I', full_table_name),
    full_table_name,
    'UPDATE',
    'auth.role() IN (''authenticated'', ''service_role'')'
  );
   PERFORM public.create_policy_if_not_exists(
    format('Enable delete for authenticated users on %I', full_table_name),
    full_table_name,
    'DELETE',
    'auth.role() IN (''authenticated'', ''service_role'')'
  );

  -- Grant permissions to service_role for the new table
  EXECUTE format('GRANT ALL PRIVILEGES ON TABLE public.%I TO service_role', full_table_name);
  -- Grant permissions to authenticated role (adjust as needed)
  EXECUTE format('GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.%I TO authenticated', full_table_name);


  RETURN TRUE;
EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Error creating dynamic table %: %', full_table_name, SQLERRM;
    RETURN FALSE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_policy_if_not_exists(p_policy_name text, p_table_name text, p_operation text, p_using_expr text, p_with_check_expr text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  policy_exists boolean;
  qualified_table_name text := 'public.' || p_table_name; -- Use renamed parameter
BEGIN
  -- Check if policy exists
  SELECT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
    AND tablename = p_table_name -- Use renamed parameter
    AND policyname = p_policy_name -- Use renamed parameter
  ) INTO policy_exists;

  -- Create policy if it doesn't exist
  IF NOT policy_exists THEN
    -- For INSERT policies, only WITH CHECK is allowed (not USING)
    IF upper(p_operation) = 'INSERT' THEN
      EXECUTE format('CREATE POLICY %I ON %s FOR %s WITH CHECK (%s)',
                  p_policy_name, qualified_table_name, upper(p_operation),
                  COALESCE(p_with_check_expr, p_using_expr));
    ELSE
      -- For other operations (SELECT, UPDATE, DELETE, ALL)
      IF p_with_check_expr IS NULL THEN
        EXECUTE format('CREATE POLICY %I ON %s FOR %s USING (%s)',
                    p_policy_name, qualified_table_name, upper(p_operation), p_using_expr);
      ELSE
        EXECUTE format('CREATE POLICY %I ON %s FOR %s USING (%s) WITH CHECK (%s)',
                    p_policy_name, qualified_table_name, upper(p_operation), p_using_expr, p_with_check_expr);
      END IF;
    END IF;
    RAISE NOTICE 'Policy "%" created for table "%".', p_policy_name, p_table_name;
  ELSE
    RAISE NOTICE 'Policy "%" already exists for table "%". Skipping.', p_policy_name, p_table_name;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.execute_sql(sql text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Only allow service_role to execute this
  IF auth.role() != 'service_role' THEN
    RETURN json_build_object('success', false, 'error', 'Permission denied');
  END IF;

  EXECUTE sql;
  RETURN json_build_object('success', true);
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('success', false, 'error', SQLERRM);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_daily_stats(campaign_id_param uuid, start_date timestamp with time zone)
 RETURNS TABLE(date date, sent bigint, delivered bigint, bounced bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  WITH days AS (
    SELECT generate_series(
      date_trunc('day', start_date),
      date_trunc('day', CURRENT_DATE),
      '1 day'::interval
    )::date as day
  ),
  email_counts AS (
    SELECT
      DATE(e.created_at) as email_date,
      COUNT(CASE WHEN e.status = 'SENT' THEN 1 END) as sent,
      COUNT(CASE WHEN e.status = 'DELIVERED' THEN 1 END) as delivered,
      COUNT(CASE WHEN e.status = 'BOUNCED' THEN 1 END) as bounced
    FROM public.emails e
    WHERE e.campaign_id = campaign_id_param
    AND e.created_at >= start_date
    GROUP BY email_date
  )
  SELECT
    d.day,
    COALESCE(ec.sent, 0)::bigint,
    COALESCE(ec.delivered, 0)::bigint,
    COALESCE(ec.bounced, 0)::bigint
  FROM days d
  LEFT JOIN email_counts ec ON d.day = ec.email_date
  ORDER BY d.day;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_sender_stats(campaign_id_param uuid)
 RETURNS TABLE(sender_id uuid, sender_name character varying, sent bigint, delivered bigint, bounced bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    s.id,
    s.name,
    COUNT(CASE WHEN e.status = 'SENT' THEN 1 END)::bigint,
    COUNT(CASE WHEN e.status = 'DELIVERED' THEN 1 END)::bigint,
    COUNT(CASE WHEN e.status = 'BOUNCED' THEN 1 END)::bigint
  FROM public.senders s
  JOIN public.campaign_senders cs ON s.id = cs.sender_id AND cs.campaign_id = campaign_id_param
  LEFT JOIN public.emails e ON s.id = e.sender_id AND e.campaign_id = campaign_id_param
  GROUP BY s.id, s.name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_table_columns()
 RETURNS SETOF information_schema.columns
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
    RETURN QUERY
    SELECT *
    FROM information_schema.columns
    WHERE table_schema = 'public'
    AND table_name NOT LIKE 'pg_%'
    AND table_name NOT LIKE '_prisma_%'
    ORDER BY table_name, ordinal_position;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.group_by_status(campaign_id_param uuid)
 RETURNS TABLE(status character varying, count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    e.status,
    COUNT(*)::bigint
  FROM public.emails e
  WHERE e.campaign_id = campaign_id_param
  AND e.status IN ('SENT', 'DELIVERED', 'BOUNCED') -- Consider other statuses?
  GROUP BY e.status;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.list_dynamic_lead_tables()
 RETURNS TABLE(table_name text, record_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  tbl text;
BEGIN
  FOR tbl IN
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema = 'public'
    AND table_name LIKE '%_leads'
    AND table_name != 'leads'
    ORDER BY table_name
  LOOP
    EXECUTE format('SELECT %L, COUNT(*) FROM public.%I', tbl, tbl) INTO table_name, record_count;
    RETURN NEXT;
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.list_normalized_lead_tables()
 RETURNS TABLE(table_name text)
 LANGUAGE sql
AS $function$
  SELECT tablename AS table_name
    FROM pg_catalog.pg_tables
    WHERE schemaname = 'public'
      AND tablename LIKE 'normalized_%';
$function$
;

CREATE OR REPLACE FUNCTION public.query_dynamic_lead_table(table_name text, query_conditions text DEFAULT ''::text, page_number integer DEFAULT 1, page_size integer DEFAULT 50, sort_field text DEFAULT 'created_at'::text, sort_direction text DEFAULT 'DESC'::text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  result json;
  total_count integer;
  query_text text;
  count_query_text text;
  safe_table_name text;
  safe_sort_field text;
  safe_sort_direction text;
BEGIN
  -- Validate sort direction
  IF upper(sort_direction) NOT IN ('ASC', 'DESC') THEN
     safe_sort_direction := 'DESC';
  ELSE
     safe_sort_direction := upper(sort_direction);
  END IF;

  -- Sanitize table name (ensure it ends with _leads and is a valid identifier)
  IF table_name NOT LIKE '%_leads' THEN
    safe_table_name := table_name || '_leads';
  ELSE
    safe_table_name := table_name;
  END IF;
  -- Further check if table exists to prevent injection (though format %I helps)
  IF NOT EXISTS (
      SELECT 1 FROM information_schema.tables
      WHERE table_schema = 'public' AND table_name = safe_table_name
  ) THEN
      RETURN json_build_object('error', 'Table not found');
  END IF;

  -- Sanitize sort field (check if column exists)
  IF NOT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = safe_table_name AND column_name = sort_field
  ) THEN
      safe_sort_field := 'created_at'; -- Default to created_at if invalid
  ELSE
      safe_sort_field := sort_field;
  END IF;

  -- First get total count
  count_query_text := format('SELECT COUNT(*) FROM public.%I', safe_table_name);
  IF query_conditions != '' THEN
    -- Basic validation/sanitization of query_conditions might be needed here depending on usage
    count_query_text := count_query_text || ' WHERE ' || query_conditions;
  END IF;

  EXECUTE count_query_text INTO total_count;

  -- Build main query with pagination and sorting
  query_text := format('SELECT * FROM public.%I', safe_table_name);
  IF query_conditions != '' THEN
    query_text := query_text || ' WHERE ' || query_conditions;
  END IF;

  query_text := query_text || format(' ORDER BY %I %s', safe_sort_field, safe_sort_direction);
  query_text := query_text || format(' LIMIT %s OFFSET %s',
                           page_size,
                           (page_number - 1) * page_size);

  -- Execute query and return results with pagination info
  EXECUTE format('
    SELECT json_build_object(
      ''data'', COALESCE(json_agg(t.*), ''[]''::json),
      ''pagination'', json_build_object(
        ''total'', %s,
        ''page'', %s,
        ''pageSize'', %s,
        ''pageCount'', CEIL(%s::float / %s)
      )
    ) FROM (%s) t',
    total_count, page_number, page_size, total_count, page_size, query_text
  ) INTO result;

  RETURN result;
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object('error', SQLERRM);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.run_sql(sql text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  EXECUTE sql;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_jsonb_return()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Directly return a simple JSONB value
    RETURN '[{"message": "Test successful"}]'::jsonb;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.exec_sql(query text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  EXECUTE query;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.normalize_staged_leads()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Clear the target table before inserting new normalized data
    TRUNCATE TABLE public.normalized_leads;

    -- Insert normalized data from the 'leads' staging table
    INSERT INTO public.normalized_leads (
        original_lead_id,
        contact_name, contact_email,
        property_address, property_city, property_state, property_postal_code,
        property_type, baths, beds, year_built, square_footage,
        wholesale_value, assessed_total, mls_curr_status, mls_curr_days_on_market
    )
    -- Block 1: Contact 1
    SELECT
        leads.id, leads.contact1name, leads.contact1email_1,
        leads.propertyaddress, leads.propertycity, leads.propertystate, leads.propertypostalcode,
        leads.propertytype, leads.baths::TEXT, leads.beds, leads.yearbuilt, leads.squarefootage,
        leads.wholesalevalue, leads.assessedtotal, leads.mls_curr_status, leads.mls_curr_daysonmarket
    FROM public.leads
    WHERE leads.contact1name IS NOT NULL AND trim(leads.contact1name) <> '' AND leads.contact1email_1 IS NOT NULL AND trim(leads.contact1email_1) <> ''
    UNION ALL
    -- Block 2: Contact 2
    SELECT
        leads.id, leads.contact2name, leads.contact2email_1,
        leads.propertyaddress, leads.propertycity, leads.propertystate, leads.propertypostalcode,
        leads.propertytype, leads.baths::TEXT, leads.beds, leads.yearbuilt, leads.squarefootage,
        leads.wholesalevalue, leads.assessedtotal, leads.mls_curr_status, leads.mls_curr_daysonmarket
    FROM public.leads
    WHERE leads.contact2name IS NOT NULL AND trim(leads.contact2name) <> '' AND leads.contact2email_1 IS NOT NULL AND trim(leads.contact2email_1) <> ''
    UNION ALL
    -- Block 3: Contact 3
    SELECT
        leads.id, leads.contact3name, leads.contact3email_1,
        leads.propertyaddress, leads.propertycity, leads.propertystate, leads.propertypostalcode,
        leads.propertytype, leads.baths::TEXT, leads.beds, leads.yearbuilt, leads.squarefootage,
        leads.wholesalevalue, leads.assessedtotal, leads.mls_curr_status, leads.mls_curr_daysonmarket
    FROM public.leads
    WHERE leads.contact3name IS NOT NULL AND trim(leads.contact3name) <> '' AND leads.contact3email_1 IS NOT NULL AND trim(leads.contact3email_1) <> ''
    UNION ALL
    -- Block 4: MLS Current Agent
    SELECT
        leads.id, leads.mls_curr_listagentname, leads.mls_curr_listagentemail,
        leads.propertyaddress, leads.propertycity, leads.propertystate, leads.propertypostalcode,
        leads.propertytype, leads.baths::TEXT, leads.beds, leads.yearbuilt, leads.squarefootage,
        leads.wholesalevalue, leads.assessedtotal, leads.mls_curr_status, leads.mls_curr_daysonmarket
    FROM public.leads
    WHERE leads.mls_curr_listagentname IS NOT NULL AND trim(leads.mls_curr_listagentname) <> '' AND leads.mls_curr_listagentemail IS NOT NULL AND trim(leads.mls_curr_listagentemail) <> '';

    -- Optional: Clear the staging table after successful normalization
    -- TRUNCATE TABLE public.leads;
END;
$function$
;

grant delete on table "public"."campaign_leads" to "anon";

grant insert on table "public"."campaign_leads" to "anon";

grant references on table "public"."campaign_leads" to "anon";

grant select on table "public"."campaign_leads" to "anon";

grant trigger on table "public"."campaign_leads" to "anon";

grant truncate on table "public"."campaign_leads" to "anon";

grant update on table "public"."campaign_leads" to "anon";

grant delete on table "public"."campaign_leads" to "authenticated";

grant insert on table "public"."campaign_leads" to "authenticated";

grant references on table "public"."campaign_leads" to "authenticated";

grant select on table "public"."campaign_leads" to "authenticated";

grant trigger on table "public"."campaign_leads" to "authenticated";

grant truncate on table "public"."campaign_leads" to "authenticated";

grant update on table "public"."campaign_leads" to "authenticated";

grant delete on table "public"."campaign_leads" to "service_role";

grant insert on table "public"."campaign_leads" to "service_role";

grant references on table "public"."campaign_leads" to "service_role";

grant select on table "public"."campaign_leads" to "service_role";

grant trigger on table "public"."campaign_leads" to "service_role";

grant truncate on table "public"."campaign_leads" to "service_role";

grant update on table "public"."campaign_leads" to "service_role";

grant delete on table "public"."campaign_senders" to "anon";

grant insert on table "public"."campaign_senders" to "anon";

grant references on table "public"."campaign_senders" to "anon";

grant select on table "public"."campaign_senders" to "anon";

grant trigger on table "public"."campaign_senders" to "anon";

grant truncate on table "public"."campaign_senders" to "anon";

grant update on table "public"."campaign_senders" to "anon";

grant delete on table "public"."campaign_senders" to "authenticated";

grant insert on table "public"."campaign_senders" to "authenticated";

grant references on table "public"."campaign_senders" to "authenticated";

grant select on table "public"."campaign_senders" to "authenticated";

grant trigger on table "public"."campaign_senders" to "authenticated";

grant truncate on table "public"."campaign_senders" to "authenticated";

grant update on table "public"."campaign_senders" to "authenticated";

grant delete on table "public"."campaign_senders" to "service_role";

grant insert on table "public"."campaign_senders" to "service_role";

grant references on table "public"."campaign_senders" to "service_role";

grant select on table "public"."campaign_senders" to "service_role";

grant trigger on table "public"."campaign_senders" to "service_role";

grant truncate on table "public"."campaign_senders" to "service_role";

grant update on table "public"."campaign_senders" to "service_role";

grant delete on table "public"."campaigns" to "anon";

grant insert on table "public"."campaigns" to "anon";

grant references on table "public"."campaigns" to "anon";

grant select on table "public"."campaigns" to "anon";

grant trigger on table "public"."campaigns" to "anon";

grant truncate on table "public"."campaigns" to "anon";

grant update on table "public"."campaigns" to "anon";

grant delete on table "public"."campaigns" to "authenticated";

grant insert on table "public"."campaigns" to "authenticated";

grant references on table "public"."campaigns" to "authenticated";

grant select on table "public"."campaigns" to "authenticated";

grant trigger on table "public"."campaigns" to "authenticated";

grant truncate on table "public"."campaigns" to "authenticated";

grant update on table "public"."campaigns" to "authenticated";

grant delete on table "public"."campaigns" to "service_role";

grant insert on table "public"."campaigns" to "service_role";

grant references on table "public"."campaigns" to "service_role";

grant select on table "public"."campaigns" to "service_role";

grant trigger on table "public"."campaigns" to "service_role";

grant truncate on table "public"."campaigns" to "service_role";

grant update on table "public"."campaigns" to "service_role";

grant delete on table "public"."email_events" to "anon";

grant insert on table "public"."email_events" to "anon";

grant references on table "public"."email_events" to "anon";

grant select on table "public"."email_events" to "anon";

grant trigger on table "public"."email_events" to "anon";

grant truncate on table "public"."email_events" to "anon";

grant update on table "public"."email_events" to "anon";

grant delete on table "public"."email_events" to "authenticated";

grant insert on table "public"."email_events" to "authenticated";

grant references on table "public"."email_events" to "authenticated";

grant select on table "public"."email_events" to "authenticated";

grant trigger on table "public"."email_events" to "authenticated";

grant truncate on table "public"."email_events" to "authenticated";

grant update on table "public"."email_events" to "authenticated";

grant delete on table "public"."email_events" to "service_role";

grant insert on table "public"."email_events" to "service_role";

grant references on table "public"."email_events" to "service_role";

grant select on table "public"."email_events" to "service_role";

grant trigger on table "public"."email_events" to "service_role";

grant truncate on table "public"."email_events" to "service_role";

grant update on table "public"."email_events" to "service_role";

grant delete on table "public"."emails" to "anon";

grant insert on table "public"."emails" to "anon";

grant references on table "public"."emails" to "anon";

grant select on table "public"."emails" to "anon";

grant trigger on table "public"."emails" to "anon";

grant truncate on table "public"."emails" to "anon";

grant update on table "public"."emails" to "anon";

grant delete on table "public"."emails" to "authenticated";

grant insert on table "public"."emails" to "authenticated";

grant references on table "public"."emails" to "authenticated";

grant select on table "public"."emails" to "authenticated";

grant trigger on table "public"."emails" to "authenticated";

grant truncate on table "public"."emails" to "authenticated";

grant update on table "public"."emails" to "authenticated";

grant delete on table "public"."emails" to "service_role";

grant insert on table "public"."emails" to "service_role";

grant references on table "public"."emails" to "service_role";

grant select on table "public"."emails" to "service_role";

grant trigger on table "public"."emails" to "service_role";

grant truncate on table "public"."emails" to "service_role";

grant update on table "public"."emails" to "service_role";

grant delete on table "public"."normalized_leads" to "anon";

grant insert on table "public"."normalized_leads" to "anon";

grant references on table "public"."normalized_leads" to "anon";

grant select on table "public"."normalized_leads" to "anon";

grant trigger on table "public"."normalized_leads" to "anon";

grant truncate on table "public"."normalized_leads" to "anon";

grant update on table "public"."normalized_leads" to "anon";

grant delete on table "public"."normalized_leads" to "authenticated";

grant insert on table "public"."normalized_leads" to "authenticated";

grant references on table "public"."normalized_leads" to "authenticated";

grant select on table "public"."normalized_leads" to "authenticated";

grant trigger on table "public"."normalized_leads" to "authenticated";

grant truncate on table "public"."normalized_leads" to "authenticated";

grant update on table "public"."normalized_leads" to "authenticated";

grant delete on table "public"."normalized_leads" to "service_role";

grant insert on table "public"."normalized_leads" to "service_role";

grant references on table "public"."normalized_leads" to "service_role";

grant select on table "public"."normalized_leads" to "service_role";

grant trigger on table "public"."normalized_leads" to "service_role";

grant truncate on table "public"."normalized_leads" to "service_role";

grant update on table "public"."normalized_leads" to "service_role";

grant delete on table "public"."senders" to "anon";

grant insert on table "public"."senders" to "anon";

grant references on table "public"."senders" to "anon";

grant select on table "public"."senders" to "anon";

grant trigger on table "public"."senders" to "anon";

grant truncate on table "public"."senders" to "anon";

grant update on table "public"."senders" to "anon";

grant delete on table "public"."senders" to "authenticated";

grant insert on table "public"."senders" to "authenticated";

grant references on table "public"."senders" to "authenticated";

grant select on table "public"."senders" to "authenticated";

grant trigger on table "public"."senders" to "authenticated";

grant truncate on table "public"."senders" to "authenticated";

grant update on table "public"."senders" to "authenticated";

grant delete on table "public"."senders" to "service_role";

grant insert on table "public"."senders" to "service_role";

grant references on table "public"."senders" to "service_role";

grant select on table "public"."senders" to "service_role";

grant trigger on table "public"."senders" to "service_role";

grant truncate on table "public"."senders" to "service_role";

grant update on table "public"."senders" to "service_role";

grant delete on table "public"."templates" to "anon";

grant insert on table "public"."templates" to "anon";

grant references on table "public"."templates" to "anon";

grant select on table "public"."templates" to "anon";

grant trigger on table "public"."templates" to "anon";

grant truncate on table "public"."templates" to "anon";

grant update on table "public"."templates" to "anon";

grant delete on table "public"."templates" to "authenticated";

grant insert on table "public"."templates" to "authenticated";

grant references on table "public"."templates" to "authenticated";

grant select on table "public"."templates" to "authenticated";

grant trigger on table "public"."templates" to "authenticated";

grant truncate on table "public"."templates" to "authenticated";

grant update on table "public"."templates" to "authenticated";

grant delete on table "public"."templates" to "service_role";

grant insert on table "public"."templates" to "service_role";

grant references on table "public"."templates" to "service_role";

grant select on table "public"."templates" to "service_role";

grant trigger on table "public"."templates" to "service_role";

grant truncate on table "public"."templates" to "service_role";

grant update on table "public"."templates" to "service_role";

create policy "Enable delete for authenticated users on campaign_leads"
on "public"."campaign_leads"
as permissive
for delete
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable delete for authenticated users"
on "public"."campaign_leads"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable insert for authenticated users on campaign_leads"
on "public"."campaign_leads"
as permissive
for insert
to public
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable insert for authenticated users"
on "public"."campaign_leads"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Enable read access for authenticated users on campaign_leads"
on "public"."campaign_leads"
as permissive
for select
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable read access for authenticated users"
on "public"."campaign_leads"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable update for authenticated users on campaign_leads"
on "public"."campaign_leads"
as permissive
for update
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])))
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable update for authenticated users"
on "public"."campaign_leads"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));


create policy "Enable delete for authenticated users on campaign_senders"
on "public"."campaign_senders"
as permissive
for delete
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable delete for authenticated users"
on "public"."campaign_senders"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable insert for authenticated users on campaign_senders"
on "public"."campaign_senders"
as permissive
for insert
to public
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable insert for authenticated users"
on "public"."campaign_senders"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Enable read access for authenticated users on campaign_senders"
on "public"."campaign_senders"
as permissive
for select
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable read access for authenticated users"
on "public"."campaign_senders"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable update for authenticated users on campaign_senders"
on "public"."campaign_senders"
as permissive
for update
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])))
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable update for authenticated users"
on "public"."campaign_senders"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));


create policy "Enable delete for authenticated users on campaigns"
on "public"."campaigns"
as permissive
for delete
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable delete for authenticated users"
on "public"."campaigns"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable insert for authenticated users on campaigns"
on "public"."campaigns"
as permissive
for insert
to public
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable insert for authenticated users"
on "public"."campaigns"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Enable read access for authenticated users on campaigns"
on "public"."campaigns"
as permissive
for select
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable read access for authenticated users"
on "public"."campaigns"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable update for authenticated users on campaigns"
on "public"."campaigns"
as permissive
for update
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])))
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable update for authenticated users"
on "public"."campaigns"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));


create policy "Enable delete for authenticated users on email_events"
on "public"."email_events"
as permissive
for delete
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable delete for authenticated users"
on "public"."email_events"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable insert for authenticated users on email_events"
on "public"."email_events"
as permissive
for insert
to public
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable insert for authenticated users"
on "public"."email_events"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Enable read access for authenticated users on email_events"
on "public"."email_events"
as permissive
for select
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable read access for authenticated users"
on "public"."email_events"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable update for authenticated users on email_events"
on "public"."email_events"
as permissive
for update
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])))
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable update for authenticated users"
on "public"."email_events"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));


create policy "Enable delete for authenticated users on emails"
on "public"."emails"
as permissive
for delete
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable delete for authenticated users"
on "public"."emails"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable insert for authenticated users on emails"
on "public"."emails"
as permissive
for insert
to public
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable insert for authenticated users"
on "public"."emails"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Enable read access for authenticated users on emails"
on "public"."emails"
as permissive
for select
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable read access for authenticated users"
on "public"."emails"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable update for authenticated users on emails"
on "public"."emails"
as permissive
for update
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])))
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable update for authenticated users"
on "public"."emails"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));


create policy "Enable delete for authenticated users on lead_sources"
on "public"."lead_sources"
as permissive
for delete
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable delete for authenticated users"
on "public"."lead_sources"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable insert for authenticated users on lead_sources"
on "public"."lead_sources"
as permissive
for insert
to public
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable insert for authenticated users"
on "public"."lead_sources"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Enable read access for authenticated users on lead_sources"
on "public"."lead_sources"
as permissive
for select
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable read access for authenticated users"
on "public"."lead_sources"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable update for authenticated users on lead_sources"
on "public"."lead_sources"
as permissive
for update
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])))
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable update for authenticated users"
on "public"."lead_sources"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));


create policy "Allow users to delete their assigned leads"
on "public"."leads"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Allow users to insert their own leads"
on "public"."leads"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Allow users to update their assigned leads"
on "public"."leads"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));


create policy "Enable delete for authenticated users on normalized_leads"
on "public"."normalized_leads"
as permissive
for delete
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable insert for authenticated users on normalized_leads"
on "public"."normalized_leads"
as permissive
for insert
to public
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable read access for authenticated users on normalized_leads"
on "public"."normalized_leads"
as permissive
for select
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable update for authenticated users on normalized_leads"
on "public"."normalized_leads"
as permissive
for update
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])))
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Service role can manage all profiles"
on "public"."profiles"
as permissive
for all
to public
using ((auth.role() = 'service_role'::text));


create policy "Users can update their own profile"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id))
with check ((auth.uid() = id));


create policy "Users can view their own profile"
on "public"."profiles"
as permissive
for select
to public
using ((auth.uid() = id));


create policy "Enable delete for authenticated users on senders"
on "public"."senders"
as permissive
for delete
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable delete for authenticated users"
on "public"."senders"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable insert for authenticated users on senders"
on "public"."senders"
as permissive
for insert
to public
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable insert for authenticated users"
on "public"."senders"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Enable read access for authenticated users on senders"
on "public"."senders"
as permissive
for select
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable read access for authenticated users"
on "public"."senders"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable update for authenticated users on senders"
on "public"."senders"
as permissive
for update
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])))
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable update for authenticated users"
on "public"."senders"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));


create policy "Enable delete for authenticated users on templates"
on "public"."templates"
as permissive
for delete
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable delete for authenticated users"
on "public"."templates"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable insert for authenticated users on templates"
on "public"."templates"
as permissive
for insert
to public
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable insert for authenticated users"
on "public"."templates"
as permissive
for insert
to public
with check ((auth.role() = 'authenticated'::text));


create policy "Enable read access for authenticated users on templates"
on "public"."templates"
as permissive
for select
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable read access for authenticated users"
on "public"."templates"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "Enable update for authenticated users on templates"
on "public"."templates"
as permissive
for update
to public
using ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])))
with check ((auth.role() = ANY (ARRAY['authenticated'::text, 'service_role'::text])));


create policy "Enable update for authenticated users"
on "public"."templates"
as permissive
for update
to public
using ((auth.role() = 'authenticated'::text))
with check ((auth.role() = 'authenticated'::text));



