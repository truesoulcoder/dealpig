import { createAdminClient } from '@/lib/supabase';
const admin = createAdminClient(); // Use the admin client factory
// Import the correct types
import { LeadSource, Lead } from '@/helpers/types';
import { PostgrestError } from '@supabase/supabase-js';
import * as crypto from 'crypto'; // For UUID generation
import Papa from 'papaparse';

// Adjust batch size as needed based on performance/limits
const BATCH_SIZE = 500;

/**
 * Normalizes leads from a specific dynamic source table and inserts them into a central target table.
 *
 * @param sourceId The UUID of the lead_sources record.
 * @param dynamicTableName The exact name of the source table containing raw leads (e.g., 'dallas_houses_leads').
 * @param columnMap A mapping from normalized field names to raw field names in the dynamic source table.
 * @returns Promise resolving to an object indicating success, message, inserted count, and optional error.
 */
export async function normalizeLeadsForSource(
  sourceId: string,
  dynamicTableName: string,
  columnMap: Record<string, string>
): Promise<{ success: boolean; message: string; insertedCount?: number; error?: any }> {
  console.log(`[NormalizeLeads] Starting normalization for sourceId: ${sourceId} from dynamic table: ${dynamicTableName}`);

  // -------- IMPORTANT: Define your TARGET table for normalized leads here --------
  const TARGET_NORMALIZED_TABLE = 'leads'; // <--- CHANGE THIS if your central table name is different
  // -------------------------------------------------------------------------------
  // Verify the target table exists (optional but recommended)
  // You might want a separate check or rely on insert errors if it doesn't exist.

  try {
    // 1. Fetch raw leads from the dynamic source table that haven't been processed yet
    console.log(`[NormalizeLeads] Fetching unprocessed raw leads from: ${dynamicTableName}`);
    const { data: rawLeads, error: fetchError } = await admin
      .from(dynamicTableName)
      .select('*') // Select all columns for mapping
      .eq('processed', false); // Filter for unprocessed leads

    if (fetchError) {
      console.error(`[NormalizeLeads] Error fetching raw leads from ${dynamicTableName}:`, fetchError);
      return { success: false, message: `Failed to fetch raw leads: ${fetchError.message}`, error: fetchError };
    }

    if (!rawLeads || rawLeads.length === 0) {
      console.log(`[NormalizeLeads] No unprocessed raw leads found in ${dynamicTableName}.`);
      return { success: true, message: 'No new leads to normalize.', insertedCount: 0 };
    }

    console.log(`[NormalizeLeads] Fetched ${rawLeads.length} raw leads from ${dynamicTableName}. Normalizing...`);

    // 2. Normalize leads based on columnMap and perform validation/coercion
    // Use the Lead interface, omitting fields generated by DB or not part of normalization input
    const allNormalizedLeads: Omit<Lead, 'id' | 'created_at' | 'updated_at' | 'status'>[] = [];
    const processedRawLeadIds: (string | number)[] = []; // Match potential raw lead ID types

    // Define required fields for a lead to be considered valid for insertion
    // Adjust this list based on your actual requirements for the TARGET_NORMALIZED_TABLE
    // Use keys from the Lead interface
    const requiredFields: (keyof Lead)[] = [
        'owner_name', // Assuming contact_name maps to owner_name
        'owner_email', // Assuming contact_email maps to owner_email
        'property_address',
        'property_city',
        'property_state',
        'property_zip' // Assuming property_postal_code maps to property_zip
        // Add any other fields that MUST have a non-empty value in the 'leads' table
    ];

    for (const rawLead of rawLeads) {
      // Use Partial<Lead> for incremental building
      const normalizedLead: Partial<Lead> = {
        id: crypto.randomUUID(), // Generate a new UUID for the normalized record (Corrected field name)
        source_id: sourceId,       // Link back to the original lead source
        raw_lead_table: dynamicTableName, // Store the source table name for provenance
        raw_lead_id: rawLead.id,         // Store the original raw lead ID for provenance
        // Initialize other fields potentially to null or default values if needed
        property_type: null,
        baths: null,
        beds: null,
        year_built: null,
        square_footage: null,
        wholesale_value: null,
        assessed_total: null,
        mls_status: null, // Changed from mls_curr_status to match Lead interface
        days_on_market: null, // Changed from mls_curr_days_on_market
        // ... other nullable fields from Lead interface
        market_value: null,
        mls_list_date: null,
        mls_list_price: null,
        owner_name: null,
        owner_email: null,
        owner_type: null,
        mailing_address: null,
        mailing_city: null,
        mailing_state: null,
        mailing_zip: null,
        assigned_to: null,
        last_contacted_at: null,
        notes: null,
      };

      let skipLead = false; // Flag to skip this lead if critical data is missing/invalid

      for (const [normalizedKey, rawKey] of Object.entries(columnMap)) {
        // Ensure normalizedKey is a valid key of the Lead interface before assignment
        if (!(normalizedKey in normalizedLead)) {
            // console.warn(`[NormalizeLeads] Skipping unknown normalized key "${normalizedKey}" from columnMap.`);
            continue; // Skip keys not present in the Lead interface
        }

        if (rawKey in rawLead && rawLead[rawKey] !== null && rawLead[rawKey] !== undefined && String(rawLead[rawKey]).trim() !== '') {
          let value: any = rawLead[rawKey];

          // --- Type Coercion & Basic Validation ---
          try {
            // Use keys from the Lead interface for the switch
            switch (normalizedKey as keyof Lead) {
              case 'beds':
              case 'baths':
              case 'square_footage':
              case 'year_built':
              case 'days_on_market': // Changed from mls_curr_days_on_market
                const intValue = parseInt(String(value).replace(/[^0-9]/g, ''), 10);
                value = !isNaN(intValue) ? intValue : null;
                break;
              case 'wholesale_value':
              case 'assessed_total':
              case 'market_value':
              case 'mls_list_price':
                const floatValue = parseFloat(String(value).replace(/[^0-9.-]/g, ''));
                value = !isNaN(floatValue) ? floatValue : null;
                break;
              case 'owner_email': // Changed from contact_email
                value = String(value).trim().toLowerCase();
                if (!/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/.test(value)) { // Slightly improved regex
                    console.warn(`[NormalizeLeads] Invalid email format "${rawLead[rawKey]}" for field "${normalizedKey}" (Raw ID: ${rawLead.id}). Setting to null.`);
                    value = null;
                }
                break;
              // Add case for date/timestamp fields like mls_list_date if needed
              // case 'mls_list_date':
              //   const dateValue = new Date(value);
              //   value = !isNaN(dateValue.getTime()) ? dateValue.toISOString() : null;
              //   break;
              default:
                value = String(value).trim();
            }
            (normalizedLead as any)[normalizedKey] = value;
          } catch (coercionError: any) {
              console.error(`[NormalizeLeads] Error during type coercion for field "${normalizedKey}" (Raw ID: ${rawLead.id}), value: "${String(rawLead[rawKey])}". Error: ${coercionError.message}. Setting to null.`);
              (normalizedLead as any)[normalizedKey] = null;
          }
          // --- End Type Coercion ---

        } else {
          (normalizedLead as any)[normalizedKey] = null;
        }
      }

      // --- Final Validation (after mapping and coercion) ---
      for (const field of requiredFields) {
          // Check if the field exists and is empty/null/undefined
          if (!(field in normalizedLead) || normalizedLead[field] === null || normalizedLead[field] === undefined || String(normalizedLead[field]).trim() === '') {
              console.warn(`[NormalizeLeads] Missing or empty required field "${String(field)}" after normalization for raw lead ID ${rawLead.id}. Skipping insertion for this lead.`);
              skipLead = true;
              break; // Stop checking this lead
          }
      }

      if (!skipLead) {
          // Cast to the Omit<Lead, ...> type only if it passes validation
          allNormalizedLeads.push(normalizedLead as Omit<Lead, 'id' | 'created_at' | 'updated_at' | 'status'>);
          processedRawLeadIds.push(rawLead.id);
      }
      // --- End Final Validation ---
    } // End loop through rawLeads

    if (allNormalizedLeads.length === 0) {
        console.log(`[NormalizeLeads] No valid leads to insert after normalization and validation for source ${sourceId}.`);
        return { success: true, message: 'No valid leads to insert after normalization.', insertedCount: 0 };
    }

    console.log(`[NormalizeLeads] Normalized ${allNormalizedLeads.length} valid leads. Preparing batch insert into '${TARGET_NORMALIZED_TABLE}'.`);

    // 3. Batch insert validated normalized leads into the target table
    let totalInserted = 0;
    let batchInsertError: PostgrestError | null = null; // Track the first error

    for (let i = 0; i < allNormalizedLeads.length; i += BATCH_SIZE) {
      const batch = allNormalizedLeads.slice(i, i + BATCH_SIZE);
      console.log(`[NormalizeLeads] Attempting to insert batch ${Math.floor(i / BATCH_SIZE) + 1}/${Math.ceil(allNormalizedLeads.length / BATCH_SIZE)} (${batch.length} rows) into ${TARGET_NORMALIZED_TABLE}...`);

      const { error: currentBatchError, count } = await admin
        .from(TARGET_NORMALIZED_TABLE)
        .insert(batch); // Insert the validated batch

      if (currentBatchError) {
        batchInsertError = currentBatchError; // Store the first error encountered
        console.error(`[NormalizeLeads] Batch insert error object (Batch ${Math.floor(i / BATCH_SIZE) + 1}):`, batchInsertError);
        console.error(`[NormalizeLeads] Batch insert error (JSON):`, JSON.stringify(batchInsertError, null, 2));
        console.error(`[NormalizeLeads] Batch insert error (toString):`, batchInsertError ? batchInsertError.toString() : 'null');
        console.error('[NormalizeLeads] Batch Insert Error Details:', {
            message: batchInsertError?.message || 'Unknown error',
            details: batchInsertError?.details,
            hint: batchInsertError?.hint,
            code: batchInsertError?.code,
        });
        console.error('[NormalizeLeads] Failing Batch Data Sample (first 5 records):', JSON.stringify(batch.slice(0, 5), null, 2));
        break;
      }

      const insertedInBatch = count ?? batch.length;
      totalInserted += insertedInBatch;
      console.log(`[NormalizeLeads] Successfully inserted batch ${Math.floor(i / BATCH_SIZE) + 1} (${insertedInBatch} rows) into ${TARGET_NORMALIZED_TABLE}. Total inserted: ${totalInserted}`);
    }

    if (batchInsertError) {
      const errorMessage = batchInsertError.message || JSON.stringify(batchInsertError);
      console.error(`[NormalizeLeads] Batch insert failed into ${TARGET_NORMALIZED_TABLE}. Error: ${errorMessage}. Total inserted before failure: ${totalInserted}`);
      return {
          success: false,
          message: `Failed to insert normalized leads batch into ${TARGET_NORMALIZED_TABLE}: ${errorMessage}`,
          error: batchInsertError,
          insertedCount: totalInserted
      };
    }

    console.log(`[NormalizeLeads] Successfully inserted all ${totalInserted} normalized leads into ${TARGET_NORMALIZED_TABLE}.`);

    if (totalInserted > 0 && processedRawLeadIds.length > 0) {
        console.log(`[NormalizeLeads] Marking ${processedRawLeadIds.length} corresponding raw leads as processed=true in ${dynamicTableName}...`);
        const { error: updateError } = await admin
          .from(dynamicTableName)
          .update({ processed: true, updated_at: new Date().toISOString() })
          .in('id', processedRawLeadIds);

        if (updateError) {
          console.error(`[NormalizeLeads] Error marking raw leads as processed in ${dynamicTableName} after successful insert:`, updateError);
          return {
              success: true,
              message: `Successfully inserted ${totalInserted} normalized leads into ${TARGET_NORMALIZED_TABLE}, but failed to mark all corresponding raw leads as processed in ${dynamicTableName}. Error: ${updateError.message}`,
              insertedCount: totalInserted
          };
        }
        console.log(`[NormalizeLeads] Successfully marked ${processedRawLeadIds.length} raw leads as processed in ${dynamicTableName}.`);
    } else if (totalInserted === 0) {
         console.log(`[NormalizeLeads] No leads were inserted, skipping marking raw leads as processed.`);
    }

    return { success: true, message: `Successfully normalized and inserted ${totalInserted} leads into ${TARGET_NORMALIZED_TABLE}.`, insertedCount: totalInserted };

  } catch (error: any) {
    console.error('[NormalizeLeads] Unexpected error during normalization process:', error);
    console.error('[NormalizeLeads] Error details:', JSON.stringify(error, null, 2));
    return { success: false, message: `An unexpected error occurred: ${error.message || String(error)}`, error };
  }
}

async function processLeadSourceFile(sourceId: string /*, other params like userId */) {
    console.log(`[ProcessLeadSource] Starting processing for sourceId: ${sourceId}`);
    try {
        console.log(`[ProcessLeadSource] Fetching lead source details for ID: ${sourceId}`);
        const { data: leadSource, error: fetchSourceError } = await admin
            .from('lead_sources')
            .select('id, metadata, name')
            .eq('id', sourceId)
            .single();

        if (fetchSourceError) {
            console.error(`[ProcessLeadSource] Error fetching lead source ${sourceId}:`, fetchSourceError);
            throw new Error(`Lead source ${sourceId} not found or error fetching: ${fetchSourceError.message}`);
        }
        if (!leadSource) {
             console.error(`[ProcessLeadSource] Lead source ${sourceId} not found.`);
             throw new Error(`Lead source ${sourceId} not found.`);
        }

        console.log(`[ProcessLeadSource] Found lead source: ${leadSource.name} (ID: ${sourceId})`);

        const dynamicTableName = leadSource.metadata?.tableName;
        const columnMap = leadSource.metadata?.columnMap;

        if (!dynamicTableName || typeof dynamicTableName !== 'string' || dynamicTableName.trim() === '') {
            console.error(`[ProcessLeadSource] Missing or invalid tableName in metadata for source ${sourceId}`);
            throw new Error(`Metadata incomplete (missing tableName) for source ${sourceId}. Cannot normalize.`);
        }
         if (!columnMap || typeof columnMap !== 'object' || Object.keys(columnMap).length === 0) {
            console.error(`[ProcessLeadSource] Missing or invalid columnMap in metadata for source ${sourceId}`);
            throw new Error(`Metadata incomplete (missing columnMap) for source ${sourceId}. Cannot normalize.`);
        }

        console.log(`[ProcessLeadSource] Extracted dynamic table name: ${dynamicTableName}`);
        console.log(`[ProcessLeadSource] Extracted column map:`, columnMap);

        console.log(`[ProcessLeadSource] Calling normalizeLeadsForSource for source ${sourceId}...`);

        const normalizationResult = await normalizeLeadsForSource(
            sourceId,
            dynamicTableName,
            columnMap
        );

        if (!normalizationResult.success) {
            console.error(`[ProcessLeadSource] Normalization failed for source ${sourceId}:`, normalizationResult.message, normalizationResult.error);
        } else {
            console.log(`[ProcessLeadSource] Normalization successful for source ${sourceId}: ${normalizationResult.message}`);
        }

        return normalizationResult;

    } catch (error: any) {
        console.error(`[ProcessLeadSource] Error processing lead source file for ${sourceId}:`, error);
        return { success: false, message: `Failed to process lead source ${sourceId}: ${error.message}`, error };
    }
}

export { processLeadSourceFile };